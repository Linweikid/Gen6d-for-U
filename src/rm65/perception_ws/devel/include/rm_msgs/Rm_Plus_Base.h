// Generated by gencpp from file rm_msgs/Rm_Plus_Base.msg
// DO NOT EDIT!


#ifndef RM_MSGS_MESSAGE_RM_PLUS_BASE_H
#define RM_MSGS_MESSAGE_RM_PLUS_BASE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace rm_msgs
{
template <class ContainerAllocator>
struct Rm_Plus_Base_
{
  typedef Rm_Plus_Base_<ContainerAllocator> Type;

  Rm_Plus_Base_()
    : manu()
    , type(0)
    , hv()
    , sv()
    , bv()
    , id(0)
    , dof(0)
    , check(0)
    , bee(0)
    , force(false)
    , touch(false)
    , touch_num(0)
    , touch_sw(0)
    , hand(0)
    , pos_up()
    , pos_low()
    , angle_up()
    , angle_low()
    , speed_up()
    , speed_low()
    , force_up()
    , force_low()  {
    }
  Rm_Plus_Base_(const ContainerAllocator& _alloc)
    : manu(_alloc)
    , type(0)
    , hv(_alloc)
    , sv(_alloc)
    , bv(_alloc)
    , id(0)
    , dof(0)
    , check(0)
    , bee(0)
    , force(false)
    , touch(false)
    , touch_num(0)
    , touch_sw(0)
    , hand(0)
    , pos_up(_alloc)
    , pos_low(_alloc)
    , angle_up(_alloc)
    , angle_low(_alloc)
    , speed_up(_alloc)
    , speed_low(_alloc)
    , force_up(_alloc)
    , force_low(_alloc)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _manu_type;
  _manu_type manu;

   typedef int8_t _type_type;
  _type_type type;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _hv_type;
  _hv_type hv;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _sv_type;
  _sv_type sv;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _bv_type;
  _bv_type bv;

   typedef int32_t _id_type;
  _id_type id;

   typedef int8_t _dof_type;
  _dof_type dof;

   typedef int8_t _check_type;
  _check_type check;

   typedef int8_t _bee_type;
  _bee_type bee;

   typedef uint8_t _force_type;
  _force_type force;

   typedef uint8_t _touch_type;
  _touch_type touch;

   typedef int8_t _touch_num_type;
  _touch_num_type touch_num;

   typedef int8_t _touch_sw_type;
  _touch_sw_type touch_sw;

   typedef int8_t _hand_type;
  _hand_type hand;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _pos_up_type;
  _pos_up_type pos_up;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _pos_low_type;
  _pos_low_type pos_low;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _angle_up_type;
  _angle_up_type angle_up;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _angle_low_type;
  _angle_low_type angle_low;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _speed_up_type;
  _speed_up_type speed_up;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _speed_low_type;
  _speed_low_type speed_low;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _force_up_type;
  _force_up_type force_up;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _force_low_type;
  _force_low_type force_low;





  typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> const> ConstPtr;

}; // struct Rm_Plus_Base_

typedef ::rm_msgs::Rm_Plus_Base_<std::allocator<void> > Rm_Plus_Base;

typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_Base > Rm_Plus_BasePtr;
typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_Base const> Rm_Plus_BaseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator1> & lhs, const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator2> & rhs)
{
  return lhs.manu == rhs.manu &&
    lhs.type == rhs.type &&
    lhs.hv == rhs.hv &&
    lhs.sv == rhs.sv &&
    lhs.bv == rhs.bv &&
    lhs.id == rhs.id &&
    lhs.dof == rhs.dof &&
    lhs.check == rhs.check &&
    lhs.bee == rhs.bee &&
    lhs.force == rhs.force &&
    lhs.touch == rhs.touch &&
    lhs.touch_num == rhs.touch_num &&
    lhs.touch_sw == rhs.touch_sw &&
    lhs.hand == rhs.hand &&
    lhs.pos_up == rhs.pos_up &&
    lhs.pos_low == rhs.pos_low &&
    lhs.angle_up == rhs.angle_up &&
    lhs.angle_low == rhs.angle_low &&
    lhs.speed_up == rhs.speed_up &&
    lhs.speed_low == rhs.speed_low &&
    lhs.force_up == rhs.force_up &&
    lhs.force_low == rhs.force_low;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator1> & lhs, const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rm_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6811b6d3be27919dd94cf28267ef3a90";
  }

  static const char* value(const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6811b6d3be27919dULL;
  static const uint64_t static_value2 = 0xd94cf28267ef3a90ULL;
};

template<class ContainerAllocator>
struct DataType< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rm_msgs/Rm_Plus_Base";
  }

  static const char* value(const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string manu              # 设备厂家\n"
"int8 type                # 设备类型 1：两指夹爪 2：五指灵巧手 3：三指夹爪\n"
"string hv                # 硬件版本\n"
"string sv                # 软件版本\n"
"string bv                # boot版本\n"
"int32 id                 # 设备ID\n"
"int8 dof                 # 自由度\n"
"int8 check               # 自检开关\n"
"int8 bee                 # 蜂鸣器开关\n"
"bool force               # 力控支持\n"
"bool touch               # 触觉支持\n"
"int8 touch_num           # 触觉个数\n"
"int8 touch_sw            # 触觉开关\n"
"int8 hand                # 手方向 1 ：左手 2： 右手\n"
"int32[] pos_up           # 位置上限,单位：无量纲\n"
"int32[] pos_low          # 位置下限,单位：无量纲\n"
"int32[] angle_up         # 角度上限,单位：0.01度\n"
"int32[] angle_low        # 角度下限,单位：0.01度\n"
"int32[] speed_up         # 速度上限,单位：无量纲\n"
"int32[] speed_low        # 速度下限,单位：无量纲\n"
"int32[] force_up         # 力上限,单位：0.001N \n"
"int32[] force_low        # 力下限,单位：0.001N \n"
;
  }

  static const char* value(const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.manu);
      stream.next(m.type);
      stream.next(m.hv);
      stream.next(m.sv);
      stream.next(m.bv);
      stream.next(m.id);
      stream.next(m.dof);
      stream.next(m.check);
      stream.next(m.bee);
      stream.next(m.force);
      stream.next(m.touch);
      stream.next(m.touch_num);
      stream.next(m.touch_sw);
      stream.next(m.hand);
      stream.next(m.pos_up);
      stream.next(m.pos_low);
      stream.next(m.angle_up);
      stream.next(m.angle_low);
      stream.next(m.speed_up);
      stream.next(m.speed_low);
      stream.next(m.force_up);
      stream.next(m.force_low);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Rm_Plus_Base_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rm_msgs::Rm_Plus_Base_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rm_msgs::Rm_Plus_Base_<ContainerAllocator>& v)
  {
    if (false || !indent.empty())
      s << std::endl;
    s << indent << "manu: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.manu);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "type: ";
    Printer<int8_t>::stream(s, indent + "  ", v.type);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "hv: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.hv);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "sv: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.sv);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "bv: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.bv);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "id: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "dof: ";
    Printer<int8_t>::stream(s, indent + "  ", v.dof);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "check: ";
    Printer<int8_t>::stream(s, indent + "  ", v.check);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "bee: ";
    Printer<int8_t>::stream(s, indent + "  ", v.bee);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "force: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.force);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "touch: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.touch);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "touch_num: ";
    Printer<int8_t>::stream(s, indent + "  ", v.touch_num);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "touch_sw: ";
    Printer<int8_t>::stream(s, indent + "  ", v.touch_sw);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "hand: ";
    Printer<int8_t>::stream(s, indent + "  ", v.hand);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pos_up: ";
    if (v.pos_up.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.pos_up.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.pos_up[i]);
    }
    if (v.pos_up.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pos_low: ";
    if (v.pos_low.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.pos_low.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.pos_low[i]);
    }
    if (v.pos_low.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "angle_up: ";
    if (v.angle_up.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.angle_up.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.angle_up[i]);
    }
    if (v.angle_up.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "angle_low: ";
    if (v.angle_low.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.angle_low.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.angle_low[i]);
    }
    if (v.angle_low.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "speed_up: ";
    if (v.speed_up.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.speed_up.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.speed_up[i]);
    }
    if (v.speed_up.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "speed_low: ";
    if (v.speed_low.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.speed_low.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.speed_low[i]);
    }
    if (v.speed_low.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "force_up: ";
    if (v.force_up.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.force_up.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.force_up[i]);
    }
    if (v.force_up.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "force_low: ";
    if (v.force_low.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.force_low.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.force_low[i]);
    }
    if (v.force_low.empty() || true)
      s << "]";
  }
};

} // namespace message_operations
} // namespace ros

#endif // RM_MSGS_MESSAGE_RM_PLUS_BASE_H
