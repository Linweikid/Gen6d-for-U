// Generated by gencpp from file rm_msgs/Rm_Plus_State.msg
// DO NOT EDIT!


#ifndef RM_MSGS_MESSAGE_RM_PLUS_STATE_H
#define RM_MSGS_MESSAGE_RM_PLUS_STATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace rm_msgs
{
template <class ContainerAllocator>
struct Rm_Plus_State_
{
  typedef Rm_Plus_State_<ContainerAllocator> Type;

  Rm_Plus_State_()
    : sys_state(0)
    , sys_err(0)
    , dof_state()
    , dof_err()
    , pos()
    , speed()
    , angle()
    , current()
    , normal_force()
    , tangential_force()
    , tangential_force_dir()
    , tsa()
    , tma()
    , touch_data()
    , force()  {
    }
  Rm_Plus_State_(const ContainerAllocator& _alloc)
    : sys_state(0)
    , sys_err(0)
    , dof_state(_alloc)
    , dof_err(_alloc)
    , pos(_alloc)
    , speed(_alloc)
    , angle(_alloc)
    , current(_alloc)
    , normal_force(_alloc)
    , tangential_force(_alloc)
    , tangential_force_dir(_alloc)
    , tsa(_alloc)
    , tma(_alloc)
    , touch_data(_alloc)
    , force(_alloc)  {
  (void)_alloc;
    }



   typedef int32_t _sys_state_type;
  _sys_state_type sys_state;

   typedef int32_t _sys_err_type;
  _sys_err_type sys_err;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _dof_state_type;
  _dof_state_type dof_state;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _dof_err_type;
  _dof_err_type dof_err;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _pos_type;
  _pos_type pos;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _speed_type;
  _speed_type speed;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _angle_type;
  _angle_type angle;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _current_type;
  _current_type current;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _normal_force_type;
  _normal_force_type normal_force;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _tangential_force_type;
  _tangential_force_type tangential_force;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _tangential_force_dir_type;
  _tangential_force_dir_type tangential_force_dir;

   typedef std::vector<uint32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint32_t>> _tsa_type;
  _tsa_type tsa;

   typedef std::vector<uint32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint32_t>> _tma_type;
  _tma_type tma;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _touch_data_type;
  _touch_data_type touch_data;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _force_type;
  _force_type force;





  typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> const> ConstPtr;

}; // struct Rm_Plus_State_

typedef ::rm_msgs::Rm_Plus_State_<std::allocator<void> > Rm_Plus_State;

typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_State > Rm_Plus_StatePtr;
typedef boost::shared_ptr< ::rm_msgs::Rm_Plus_State const> Rm_Plus_StateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rm_msgs::Rm_Plus_State_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rm_msgs::Rm_Plus_State_<ContainerAllocator1> & lhs, const ::rm_msgs::Rm_Plus_State_<ContainerAllocator2> & rhs)
{
  return lhs.sys_state == rhs.sys_state &&
    lhs.sys_err == rhs.sys_err &&
    lhs.dof_state == rhs.dof_state &&
    lhs.dof_err == rhs.dof_err &&
    lhs.pos == rhs.pos &&
    lhs.speed == rhs.speed &&
    lhs.angle == rhs.angle &&
    lhs.current == rhs.current &&
    lhs.normal_force == rhs.normal_force &&
    lhs.tangential_force == rhs.tangential_force &&
    lhs.tangential_force_dir == rhs.tangential_force_dir &&
    lhs.tsa == rhs.tsa &&
    lhs.tma == rhs.tma &&
    lhs.touch_data == rhs.touch_data &&
    lhs.force == rhs.force;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rm_msgs::Rm_Plus_State_<ContainerAllocator1> & lhs, const ::rm_msgs::Rm_Plus_State_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rm_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
{
  static const char* value()
  {
    return "decaf5adc4942742a6b89965c207ee54";
  }

  static const char* value(const ::rm_msgs::Rm_Plus_State_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xdecaf5adc4942742ULL;
  static const uint64_t static_value2 = 0xa6b89965c207ee54ULL;
};

template<class ContainerAllocator>
struct DataType< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rm_msgs/Rm_Plus_State";
  }

  static const char* value(const ::rm_msgs::Rm_Plus_State_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 sys_state                 #系统状态\n"
"int32 sys_err                   #系统错误\n"
"int32[] dof_state               #各自由度当前状态\n"
"int32[] dof_err                 #各自由度错误信息\n"
"int32[] pos                     #各自由度当前位置\n"
"int32[] speed                   #各自由度当前速度\n"
"int32[] angle                   #各自由度当前角度\n"
"int32[] current                 #各自由度当前电流\n"
"int32[] normal_force            #自由度触觉三维力的法向力\n"
"int32[] tangential_force        #自由度触觉三维力的切向力\n"
"int32[] tangential_force_dir    #自由度触觉三维力的切向力方向\n"
"uint32[] tsa                    #自由度触觉自接近\n"
"uint32[] tma                    #自由度触觉互接近\n"
"int32[] touch_data              #触觉传感器原始数据\n"
"int32[] force                   #自由度力矩\n"
;
  }

  static const char* value(const ::rm_msgs::Rm_Plus_State_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.sys_state);
      stream.next(m.sys_err);
      stream.next(m.dof_state);
      stream.next(m.dof_err);
      stream.next(m.pos);
      stream.next(m.speed);
      stream.next(m.angle);
      stream.next(m.current);
      stream.next(m.normal_force);
      stream.next(m.tangential_force);
      stream.next(m.tangential_force_dir);
      stream.next(m.tsa);
      stream.next(m.tma);
      stream.next(m.touch_data);
      stream.next(m.force);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Rm_Plus_State_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rm_msgs::Rm_Plus_State_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rm_msgs::Rm_Plus_State_<ContainerAllocator>& v)
  {
    if (false || !indent.empty())
      s << std::endl;
    s << indent << "sys_state: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sys_state);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "sys_err: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sys_err);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "dof_state: ";
    if (v.dof_state.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.dof_state.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.dof_state[i]);
    }
    if (v.dof_state.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "dof_err: ";
    if (v.dof_err.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.dof_err.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.dof_err[i]);
    }
    if (v.dof_err.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pos: ";
    if (v.pos.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.pos.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.pos[i]);
    }
    if (v.pos.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "speed: ";
    if (v.speed.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.speed.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.speed[i]);
    }
    if (v.speed.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "angle: ";
    if (v.angle.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.angle.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.angle[i]);
    }
    if (v.angle.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "current: ";
    if (v.current.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.current.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.current[i]);
    }
    if (v.current.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "normal_force: ";
    if (v.normal_force.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.normal_force.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.normal_force[i]);
    }
    if (v.normal_force.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "tangential_force: ";
    if (v.tangential_force.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.tangential_force.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.tangential_force[i]);
    }
    if (v.tangential_force.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "tangential_force_dir: ";
    if (v.tangential_force_dir.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.tangential_force_dir.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.tangential_force_dir[i]);
    }
    if (v.tangential_force_dir.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "tsa: ";
    if (v.tsa.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.tsa.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<uint32_t>::stream(s, true ? std::string() : indent + "    ", v.tsa[i]);
    }
    if (v.tsa.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "tma: ";
    if (v.tma.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.tma.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<uint32_t>::stream(s, true ? std::string() : indent + "    ", v.tma[i]);
    }
    if (v.tma.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "touch_data: ";
    if (v.touch_data.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.touch_data.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.touch_data[i]);
    }
    if (v.touch_data.empty() || true)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "force: ";
    if (v.force.empty() || true)
      s << "[";
    for (size_t i = 0; i < v.force.size(); ++i)
    {
      if (true && i > 0)
        s << ", ";
      else if (!true)
        s << std::endl << indent << "  -";
      Printer<int32_t>::stream(s, true ? std::string() : indent + "    ", v.force[i]);
    }
    if (v.force.empty() || true)
      s << "]";
  }
};

} // namespace message_operations
} // namespace ros

#endif // RM_MSGS_MESSAGE_RM_PLUS_STATE_H
